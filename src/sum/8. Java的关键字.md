#### 1. 访问控制

> - private：私有的，只能在声明private(内部类)、方法或字段的类中引用这些类、方法或字段
> - 默认：**跨包情况下，默认的变量不能被子类继承且实例对象也无法访问默认修饰的变量**，但在非跨包的子类，又可以继承默认的属性和访问。
> - protected：受保护的，声明protected类、方法或字段的类、同一个包中的其他任何类以及子类引用类、方法或字段的类，**但是当子类在跨包的情况下，只能继承父类的protect字段，但是实例对象不能访问它的属性**
> - public：公共的，可以在其他任何类或包中引用public类、方法或字段
>
> | 访问权限 | 当前类 | 包   | 子类                                                         | 其他包 |
> | -------- | ------ | ---- | ------------------------------------------------------------ | ------ |
> | public   | √      | √    | √                                                            | √      |
> | protect  | √      | √    | √(跨包的子类只能继承父类的protect字段<br>但是实例对象访问不了它的属性) | ×      |
> | default  | √      | √    | ×(跨包情况下不能被子类继承<br>但是非跨包下子类又可以访问和继承它的属性) | ×      |
> | private  | √      | ×    | ×                                                            | ×      |

#### 2. 类方法和变量修饰符

> - abstract：声明抽象类或方法，可以被实现或继承；
>   - **抽象类不能直接实例化**
>   - **抽象方法只能被它的子类重写实现，不能在声明类中实现**
> - class：声明类，是面向对象的基本构造单位
> - extends：继承，可以对类或接口使用；**子类不继承父类的构造方法**，**子类可以重写父类任何非final方法**，**且一个子类只能继承一个父类**
> - final：可以修饰类，方法，变量
>
>   - 修饰类：表明类不能有子类：**final类中的所有成员方法都被隐式指定为final方法**，但成员变量不默认指定**(修饰类时abstract和final会冲突)**
>   - 修饰方法：防止任何继承类修改它的含义，在早期版本为了效率，会将final方法转为内嵌调用，现在不需要了，还有**private方法会被隐式指定为final方法**
>   - 修饰变量：
>     - 对基本类型，初始化后就不能更改；
>     - **对引用类型，不能指向其他对象，但是对象的内容是可变的**，要在使用之前赋值(编译器编译时知道确却值，会优化当作常量使用)
>     - **局部内部类和匿名内部类只能访问局部final变量。因为这里的局部变量，需要在编译阶段便需要确定下来的。也就是说，如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值**
>   - 修饰参数：同变量，只能使用该参数
>
> - implements：实现接口，**一个类可以实现多个接口**(类必须实现接口声明的所有方法)
> - interface：声明接口：方法的集合
> - native：应用于方法，指示该方法是用Java以外的语言实现(Java无法直接访问到操作系统底层，而使用native扩展)，实现步骤：
>
>   1. 在Java中声明native方法，然后编译；
>   2. 用javah产生一个.h文件
>   3. 写一个.cpp文件实现native到出方法，其中需要包含第二步产生的.h文件(包含了JDK带的jni.h文件)
>   4. 将.cpp编译成动态链接库文件
>   5. 在Java中用System.loadLibrary()方法加载动态链接库文件：此时native就可以访问了
> - new：其后的参数必须是类名，并且类名后面必须是一组构造方法参数(必须带括号，而且参数要对应)
> - static：
>
>   1. 修饰属性：所有对象共同使用唯一一份静态的成员变量
>   2. 修饰代码块：完成一些初始化操作(**首先执行静态代码块，然后执行构造方法，即类被加载时执行，且只执行一次**)
>   3. 修饰方法：**静态方法，只能继承，不能重写(会与多态冲突)；可以在静态方法中访问静态的成员变量，但不能访问非静态的成员变量；不能使用this关键字(静态方法可以直接用类名来调用，而this代表当前实例)**
>   4. 修饰类：只能用来修饰内部类(被static所修饰的内部类可以用new关键字直接创建一个实例，而不需要先创建外部类实例，可以被其他类实例化和引用)
> - strictfp：精确浮点的意思：一旦使用strictfp来声明**一个类、接口或者方法**时，那么声明的范围内Java编译器以及运行环境会完全依照浮点规范**IEEE - 754**来执行(**不能对接口中的方法或构造函数使用**)
> - synchronized：线程、同步，可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护(**防止一次被多个线程执行**)
>
>   - **对于静态方法：一个线程执行时，整个类被锁定**
>   - **对于实例方法：一个线程执行时，实例被锁定**
>   - **对于对象或数组：一个线程执行时，对象或数组将被锁定**
>   - **synchronized块：当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块；**
> - transient：短暂，**应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化**。
> - volatile：易失，表示可以被多个线程异步修改的成员变量(目标是为了确保所有线程所看到的指定变量的值是相同的：Volatile修饰的成员变量在每次被线程访问时，都强迫从主内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到主内存)，相比于synchronized效率不好，但是运行时开销较少

#### 3. 程序控制

> - break：跳出，中断循环
> - continue：继续，进入循环的下一个迭代
> - return：返回
> - do：运行和while连用
> - while：循环
> - if：如果
> - else：否则
> - for：循环
> - instanceof：确定对象所属的类
> - switch：观察，和case连用
> - case：返回观察里的结果
> - default：默认，标记switch...case的default分支

#### 4. 错误处理

> - try：**用于包含可能引发异常的语句块，必须有一个catch或finally子句**
>
>   > 如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息
>
> - catch：处理异常
>
>   > 如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息
>
> - throw：抛出一个异常对象
>
>   > throw 语句将 java.lang.Throwable 作为参数。Throwable 在调用栈中向上传播，直到被适当的 catch 块捕获。 引发非 RuntimeException 异常的任何方法还必须在方法声明中使用 throws 修饰符来声明它引发的异常。
>
> - throws：声明一个异常可能被抛出
>
>   > 引发非 RuntimeException 异常的任何方法还必须在方法声明中使用 throws 修饰符来声明它引发的异常。 要在 try-catch 块中包含带 throws 子句的方法的调用，必须提供该方法的调用者。
>
> - finally：通常在异常处理中，无论成不成功都会执行的语句块，常用来释放资源什么的。

#### 5. 包相关

> - import：**从1.4开始，Java编译器不再支持import未命名包名的类或接口(不命名都放在默认包下)，可以使用反射机制进行调用**
> - package：指定在源文件中声明的类所驻留的Java包；**若没有包含该语句，就会默认该类位于默认包下**

#### 6. 基本类型

> - boolean：布尔型1
> - byte：字节型1
> - char：字符型2
> - double：双精度浮点型：8
> - float：单精度浮点型：4
> - int：整数：4
> - long：长整型：8
> - short：短整型：2
> - null：保留字，表示无值，将 null 赋给非原始变量相当于释放该变量先前所引用的对象
> - true：真
> - false：假

#### 7. 变量引用

> - super：父类，超类，用于引用使用该关键字的类的超类，作为独立语句出现的 super 表示调用超类的构造方法。 super.() 表示调用超类的方法
> - this：引用当前实例
> - void：无返回值

#### 8. 保留字

> - goto：跳转，保留字，java不容许goto跳转
> - const：静态，保留字，声明对象不能更新